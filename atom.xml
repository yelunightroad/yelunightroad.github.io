<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜路漫漫</title>
  
  <subtitle>水深流缓，人贵语迟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-12T09:13:10.827Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>邸宇飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>永远不要使用array_merge</title>
    <link href="http://yoursite.com/2018/12/12/%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8array-merge/"/>
    <id>http://yoursite.com/2018/12/12/永远不要使用array-merge/</id>
    <published>2018-12-12T17:02:15.000Z</published>
    <updated>2018-12-12T09:13:10.827Z</updated>
    
    <content type="html"><![CDATA[<p>array_merge是php中的一个常用函数，我在之前也经常使用这个函数，知道有一天我发现我的程序运行的比预想中要慢的多，经过逐行排查发现竟然是array_merge函数惹得祸</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$primes = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">while</span> (xxx)</span><br><span class="line">&#123;</span><br><span class="line">    $data = get_some_data();</span><br><span class="line">$primes = array_merge($primes, $data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你使用类似上面的函数去不断的合并数组，尤其是最终结果较大时你会发现时间变得不可忍受。</p><p>解决的方法也很简单</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$primes = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">while</span> (xxx)</span><br><span class="line">&#123;</span><br><span class="line">    $data = get_some_data();</span><br><span class="line">    <span class="keyword">foreach</span>($data <span class="keyword">as</span> $val) &#123;</span><br><span class="line">        $primes[] = $val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>差别大到你无法想象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;array_merge是php中的一个常用函数，我在之前也经常使用这个函数，知道有一天我发现我的程序运行的比预想中要慢的多，经过逐行排查发现竟然是array_merge函数惹得祸&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>mysqlpp避坑指南</title>
    <link href="http://yoursite.com/2018/11/27/mysqlpp%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/11/27/mysqlpp避坑指南/</id>
    <published>2018-11-27T21:13:41.000Z</published>
    <updated>2018-12-12T09:13:10.796Z</updated>
    
    <content type="html"><![CDATA[<p>开发线上服务的过程中避免不了使用到数据库，由于使用了c++进行开发，在连接mysql的过程中我们使用了mysql++来进行链接，但是在使用过程中遇到了很多意想不到的情况，我们记录如下</p><hr><p><strong>mysql服务器版本</strong>：5.6.36</p><p><strong>mysql++版本</strong>：3.2.4</p><hr><p>问题的核心在于作为一个线上服务，我们显然希望使用长连接来增加效率，所以第一步我们需要调整数据库的连接关闭时间，默认为8小时，通常是够用的，但是如果使用公司dba提供的实例的话需要额外注意这个时间，最好调整到一小时以上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait_timeout=3600</span><br></pre></td></tr></table></figure><p>即使是调整了这个时间，我们也无法保证在时限内一定有用户访问，所以当连接断开时我们一定要考虑重连的问题，经过查询我们找到了最简单的解决问题的方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqlpp::Connection m_con_;</span><br><span class="line">m_con_.set_option( <span class="keyword">new</span> mysqlpp::ReconnectOption(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure><p>然而理想很丰满，显示很骨感，该设置无效，在网上也有想过的案例，所以改用其它方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_con_.connected()</span><br><span class="line">m_con_.ping()</span><br></pre></td></tr></table></figure><p>以上两个方法都是判断数据库连接是否可用，ping()方法比connected()方法更加可靠，因为connected()只是判断你是否进行过成功的connect()操作，至于后来是否还可用就不是它的职责了，理论上我们只需要在请求mysql之前先判断一下，然后如果断开连接进行重连就好了。然而事实是<strong>进行了connect之后第一次调用connected方法返回true，但是第二次开始就返回false了</strong>，我们只好把希望放在ping()方法上，然而查看mysql++源码得知ping()方法会调用connected()方法，所以这条路走不通了。</p><p>最后我们采用了以下方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CMysqlClient::Reconnect() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m_con_.disconnect();</span><br><span class="line">        m_con_.set_option(<span class="keyword">new</span> mysqlpp::SetCharsetNameOption(<span class="string">"utf8"</span>));</span><br><span class="line">        <span class="keyword">if</span> (!m_con_.connect(m_mysql_dbname_.c_str(), m_mysql_dbhost_.c_str(), m_mysql_dbuser_.c_str(), m_mysql_dbpass_.c_str() )) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> ( <span class="keyword">const</span> mysqlpp::Exception&amp; e ) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//mysql查询</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">const</span> mysqlpp::BadQuery&amp; bq) &#123;</span><br><span class="line">Reconnect();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当链接丢失时，进行mysql查询会抛出<code>mysqlpp::BadQuery</code>异常，这是进行重连即可。</p><p><strong>注意</strong></p><p>代码的第三行，在进行重连之前我们进行了<code>disconnect()</code>操作，理论上异常的时候连接已经丢失，不需要该操作，但是实际使用中我们发现，没用改语句的情况下，在有些机器上没问题，但是在有些机器上第4行的<code>set_option()</code>命令会抛出异常，所以我们加入了第3行的操作。</p><p>以上就是我们在使用mysql++访问数据库是遇到的所有问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开发线上服务的过程中避免不了使用到数据库，由于使用了c++进行开发，在连接mysql的过程中我们使用了mysql++来进行链接，但是在使用过程中遇到了很多意想不到的情况，我们记录如下&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;mysql服务器版本&lt;/strong&gt;：5.6.3
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="长连接" scheme="http://yoursite.com/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="mysql++" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="mysqlpp" scheme="http://yoursite.com/tags/mysqlpp/"/>
    
  </entry>
  
  <entry>
    <title>EM算法小结</title>
    <link href="http://yoursite.com/2018/07/13/EM%E7%AE%97%E6%B3%95%E6%91%98%E8%A6%81/"/>
    <id>http://yoursite.com/2018/07/13/EM算法摘要/</id>
    <published>2018-07-13T10:03:59.000Z</published>
    <updated>2018-12-12T09:13:10.780Z</updated>
    
    <content type="html"><![CDATA[<p>EM算法是机器学习领域常见的一种算法了，由于最近又多次看到跟其相关的东西，所以做一个小结以备忘。</p><p>个人认为EM中最终的是理解参数和隐状态这两个点。此处引用李航《统计学习方法》中的例子来做说明。</p><blockquote><p>假设有三枚硬币A、B、C，这些硬币正面出现的概率分别是 ππ 、pp 、qq 。进行如下掷硬币试验： 先掷A，如果A是正面则再掷B，如果A是反面则再掷C。对于B或C的结果，如果是正面则记为1，如果是反面则记为0。进行 NN 次独立重复实验，得到结果。现在只能观测到结果，不能观测到掷硬币的过程，估计模型参数 θ=(π,p,q) 。 </p></blockquote><p>在这个问题中，实验结果是可观测数据$ Y=(y_1,…,y_N)$，硬币A的结果是不可观测数据 $Z=(z_1,…,z_N)$且 z 只有两种可能取值1和0。</p><p>我们需要求得$\hat{\theta}=arg max<em>{\theta}{logP(Y|\theta)}$这个问题没有解析解，只能迭代求解，因为$p(y|\theta)=\sum</em>{Z}P(Z|\theta)P(Y|Z,\theta)$需要依赖于隐状态。所以就想出了一种迭代求值的方式</p><p>先假设一个初始参数$\theta^0$</p><p>E步被称为期望步，通俗点说就是利用上一步的参数$\theta^{i-1}$，以此参数求出隐状态的条件概率概率，严谨一点定义的话我们需要传说中的Q函数：完全数据的对数似然函数（观测数据和隐变量数据构成完全数据）关于在给定观测数据Y和当前参数$\theta^{i-1}$下对未观测数据Z的条件概率分布的期望。公式如下：<br>$$<br>\begin{aligned}<br>Q(\theta,\theta^{(i)})&amp;=E<em>Z[logP(Y,Z|\theta)]\<br>&amp;=\sum</em>{Z}logP(Y,Z|\theta)P(Z|Y,\theta^{(i-1)})<br>\end{aligned}<br>\tag{1}\label{1}<br>$$<br>这里，$P(Z|Y,\theta^{(i-1)})$是在给定观测数据Y和上一轮参数估计$\theta^{(i-1)}$下隐变量数据Z的条件概率分布，也就是我们E步求得最重要的一个值，三硬币模型中就是求得$y_j$来自硬币B的概率（已知y和$\theta$求得硬币A证明朝上的概率）</p><p>M步：求使$Q(\theta,\theta^{(i)})$极大化的$\theta$，更新$\theta^{(i)}=arg \max_{\theta}Q(\theta,\theta^{(i-1)})$，在三硬币模型中也就是知道每次硬币来自硬币B的概率$\mu<em>i$的情况下更新参数$\theta$，二项分布最优值为$\frac{k}{n}$时，$\pi^{(i)}=\frac{1}{n}\sum</em>{j=1}^{n}\mu<em>j^{i}$，$p^{(i)}=\frac{\sum</em>{j=1}^{n}\mu_j^{i}y<em>i}{\sum</em>{j=1}^{n}\mu_j^{i}}$</p><p>至于为什么不断迭代Q函数就可以获取有隐状态下的最大似然，用Jensen不等式证明，这里不展开。</p><p>再通过几个例子加强下</p><p><strong>例1:</strong>现在一个班里有100个男生，100个女生。我们假定男生的身高服从正态分布 ，女生的身高则服从另一个正态分布：  。假如男女是分开的，这时候我们可以用极大似然法（MLE），分别通过这100个男生和100个女生的样本来估计这两个正态分布的参数。但现在情况要更复杂一点，就是这100个男生和100个女生混在一起了。我们拥有100个人的身高数据，却不知道这100个人每一个是男生还是女生。</p><p>那么我们一个样本是男生还是女生就是一个隐状态。</p><p>E步，我们利用先验知识之类的先假设出男生和女生的正态分布参数（或者来自于迭代的上一步），这样我们就可以估算出一个样本是男生还是女生</p><p>M步，我们区分出了每个样本是男生还是女生，就可以更新正态分布参数</p><p><strong>例2：</strong>对于常见的k-means算法，我们认为每个点属于哪个模型是隐状态，聚类中心点是参数</p><p>E步，假设一些聚类中心点，求取隐状态每个点的类别</p><p>M步，根据隐状态更新中心点</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>理解EM算法最重要的个人认为是找到隐状态和参数，E步根据参数求取隐状态，M步根据隐状态求取是Q函数最大的参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;EM算法是机器学习领域常见的一种算法了，由于最近又多次看到跟其相关的东西，所以做一个小结以备忘。&lt;/p&gt;
&lt;p&gt;个人认为EM中最终的是理解参数和隐状态这两个点。此处引用李航《统计学习方法》中的例子来做说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设有三枚硬币A、B、C，
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="EM" scheme="http://yoursite.com/tags/EM/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow中的axis理解</title>
    <link href="http://yoursite.com/2018/04/11/TensorFlow%E4%B8%AD%E7%9A%84axis%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/11/TensorFlow中的axis理解/</id>
    <published>2018-04-11T20:05:01.000Z</published>
    <updated>2018-12-12T09:13:10.780Z</updated>
    
    <content type="html"><![CDATA[<p>在TensorFlow的很多函数中都有到了axis参数，对于这个参数怎么理解容易让人犯晕，二维情况下还好，如果升到高维更加难以理解，所以本文用三维情况下的两个常见函数为例，让我们彻底理解这个参数的意义。</p><p>在开始之前，先开宗明义，axis参数的意义就是在哪个维度上做操作</p><h2 id="tf-reduce-max"><a href="#tf-reduce-max" class="headerlink" title="tf.reduce_max()"></a>tf.reduce_max()</h2><p>在介绍这个函数之前，我们先简单说一下reduce的含义，这个操作无论在python或者是更高级的mapreduce中都会碰到，我对它的解释就是对列表中的元素做某一连续操作。例如reduce_max就是做连续的max操作，例如对列表<code>[1,2,3,4]</code>进行reduce_max就是先对元素1和2进行max操作，然后其结果和3再做max，再然后结果和4做max。理解了reduce操作后我们自然就明白了axis的必要性，如果把一个多维数组简单的当做一个一维列表的话进行reduce操作毫无疑问是没问题的，事实上如果不加axis参数的话，tf.reduce_max就是这么干的。</p><p>例如如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">a=[[[1,2,3,4],[5,6,7,8],[8,9,10,11]],[[11,12,13,14],[15,16,17,18],[19,20,21,22]]]</span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">print tf.reduce_max(a).eval()</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure><p>但是有时候我们不希望这么简单粗暴，毕竟如果这么计算的话我们定义这么复杂的结构就毫无意义了，例如我们有一个二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s=[[14,175],</span><br><span class="line">   [13,182]]</span><br></pre></td></tr></table></figure><p>代表了我们班里有两个同学，小明14岁身高175，小刚13岁身高182，我们想通过一个运算获取班里最大的同学多少岁，以及最高的同学多高，这个时候axis就排上了用场，用上面的例子来说，axis为0表示同学维度，axis为1表示同学自身属性维度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  ___属性__</span><br><span class="line">| </span><br><span class="line">学[[14,175],</span><br><span class="line">生[13,182]]</span><br><span class="line">|</span><br></pre></td></tr></table></figure><p>在维度0运行reduce操作表示在学生维度上进行迭代，最终学生维度小时，两个属性维度保留，我们得到了一个‘超级学生’，岁数最大，身高最高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print tf.reduce_max(s,0).eval()  #output: [ 14 182]</span><br></pre></td></tr></table></figure><p>在维度1上运行reduce操作表示在属性维度上进行迭代，我们依然保留了两个‘学生’，只不过他的属性只剩下了最突出（max）的一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print tf.reduce_max(s,0).eval()  #output: [ 175 182]</span><br></pre></td></tr></table></figure><p>虽然两个运算后都只留下了1维，但是一维中的两个元素的含义是不同的。</p><hr><p>有了上面的简单示例，我们再用一个稍复杂的例子加深印象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">a=[[[1,2,3,4],[5,6,7,8],[8,9,10,11]],[[11,12,13,14],[15,16,17,18],[19,20,21,22]]]</span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">print tf.reduce_max(a,0).eval()</span><br><span class="line">print tf.reduce_max(a,1).eval()</span><br><span class="line">print tf.reduce_max(a,2).eval()</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[11 12 13 14]</span><br><span class="line"> [15 16 17 18]</span><br><span class="line"> [19 20 21 22]]</span><br><span class="line">[[ 8  9 10 11]</span><br><span class="line"> [19 20 21 22]]</span><br><span class="line">[[ 4  8 11]</span><br><span class="line"> [14 18 22]]</span><br></pre></td></tr></table></figure><p>这是一个[2,3,4]维的数组，怎么找每一维呢，很简单，一个中括号代表一维，最外侧的中括号是第0维，我们可以看成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=[A1，B1]  #第0维</span><br><span class="line">A=[[1,2,3,4],[5,6,7,8],[8,9,10,11]]</span><br><span class="line">B=[[11,12,13,14],[15,16,17,18],[19,20,21,22]]</span><br><span class="line">A=[AA,AB,AC]</span><br><span class="line">AA=[1,2,3,4]</span><br><span class="line">AB=[5,6,7,8]</span><br><span class="line">AC=[19,20,21,22]</span><br></pre></td></tr></table></figure><p>对第0维操作，就是求A和B较大值（按对应元素求），所以得到一个[3,4]维度的数组</p><p>第1维也很明显了，就是A1和B1，那么对第1维操作时，第0维不动，仍然是A，B，但是对A、B本身要进行操作(这里就跟前面的二维数组类似了)，以A为例，要求AA，AB，AC的最大值（按对应元素求），所以A变为了[ 8  9 10 11]，B变为了[19 20 21 22]</p><p>第2维留给读者练习</p><h2 id="tf-concat"><a href="#tf-concat" class="headerlink" title="tf.concat()"></a>tf.concat()</h2><p>与reduce不同，reduce可以看成是对某一维的缩减，但是concat作为一个连接操作，则是对某一维的扩充。</p><p>请看如下示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">a=[[14,175],</span><br><span class="line">   [13,182]]</span><br><span class="line">b=[[14,173],</span><br><span class="line">   [15,180]]</span><br><span class="line">sess = tf.InteractiveSession()</span><br><span class="line">print tf.concat([a,b],0).eval() #可以看成两班学生合并，因为是在学生维度合并</span><br><span class="line">print tf.concat([a,b],1).eval()</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[ 14 175]</span><br><span class="line"> [ 13 182]</span><br><span class="line"> [ 14 173]</span><br><span class="line"> [ 15 180]]</span><br><span class="line">[[ 14 175  14 173]</span><br><span class="line"> [ 13 182  15 180]]</span><br></pre></td></tr></table></figure><p>按照第0维连接，则[2,2]变成了[4,2]，也即可以看成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[A,B]</span><br><span class="line">b=[C,D]</span><br><span class="line">#连接后是[A,B,C,D]</span><br></pre></td></tr></table></figure><p>按照第1维连接，要保证0维还是两个元素，然后要对A进行操作，和C合并。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>axis的意义就是你选择的操作在某一维度上执行，执行后的结果与你选择的操作有关，你选择reduce操作后，所选择维度小时，你选择concat操作后所选择维度进行连接，元素扩展，多tensor操作时按照对应位置进行操作，如concat示例中A对应C，选择维度直观上说就是看第几层括号，以最后一个示例为例，维度0就是最外层括号内元素变化，维度1就是里层括号<code>A=[14,175]</code>合并了<code>C=[13,173]</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在TensorFlow的很多函数中都有到了axis参数，对于这个参数怎么理解容易让人犯晕，二维情况下还好，如果升到高维更加难以理解，所以本文用三维情况下的两个常见函数为例，让我们彻底理解这个参数的意义。&lt;/p&gt;
&lt;p&gt;在开始之前，先开宗明义，axis参数的意义就是在哪个维度
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://yoursite.com/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
      <category term="tf.reduce_max" scheme="http://yoursite.com/tags/tf-reduce-max/"/>
    
      <category term="tf.concat，axis" scheme="http://yoursite.com/tags/tf-concat%EF%BC%8Caxis/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow中tfRecord的使用以及测试</title>
    <link href="http://yoursite.com/2018/04/09/tensorflow%E4%B8%ADtfRecord%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/04/09/tensorflow中tfRecord的使用以及测试/</id>
    <published>2018-04-09T17:57:45.000Z</published>
    <updated>2018-12-12T09:13:10.827Z</updated>
    
    <content type="html"><![CDATA[<p>tfRecord是TensorFlow官方推荐的标准数据格式，对于存储字典类型的数据比较友好，所以撰写此文记录一下使用过程中的一点经验。</p><h2 id="tfRecord结构"><a href="#tfRecord结构" class="headerlink" title="tfRecord结构"></a>tfRecord结构</h2><p>tfRecord中存储的记录由tf.train.Example定义，其实就是一个protocol buffer文件，定义如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">message Example &#123;</span><br><span class="line"> Features features = 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message Features&#123;</span><br><span class="line"> map&lt;string,Feature&gt; featrue = 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message Feature&#123;</span><br><span class="line">    oneof kind&#123;</span><br><span class="line">        BytesList bytes_list = 1;</span><br><span class="line">        FloatList float_list = 2;</span><br><span class="line">        Int64List int64_list = 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到其主要包含了一个字符串格式的key，以及字符串、浮点数或者整数类型的列表构成的value</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">keys=[[<span class="number">1.0</span>,<span class="number">2.0</span>],[<span class="number">2.0</span>,<span class="number">3.0</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">keys2=[[<span class="number">1.0</span>,<span class="number">2.0</span>],[<span class="number">2.0</span>,<span class="number">3.0</span>],[<span class="number">3.0</span>]]</span><br><span class="line"></span><br><span class="line">strtest=<span class="string">'aaa'</span></span><br><span class="line">sess=tf.InteractiveSession()</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br></pre></td></tr></table></figure><p>基础变量，没什么可解释的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_example</span><span class="params">(key)</span>:</span></span><br><span class="line">    example = tf.train.Example(features=tf.train.Features(</span><br><span class="line">        feature=&#123;</span><br><span class="line">            <span class="string">'ft'</span>:tf.train.Feature(float_list=tf.train.FloatList(value=key)),</span><br><span class="line">            <span class="string">'st'</span>:tf.train.Feature(bytes_list=tf.train.BytesList(value=[strtest]))</span><br><span class="line">        &#125;</span><br><span class="line">    ))</span><br><span class="line">    <span class="keyword">return</span> example</span><br><span class="line"></span><br><span class="line">filename=<span class="string">"tmp.tfrecords"</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(filename):</span><br><span class="line">    os.remove(filename)</span><br><span class="line">writer = tf.python_io.TFRecordWriter(filename)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    ex = make_example(key)</span><br><span class="line">    writer.write(ex.SerializeToString())</span><br><span class="line">writer.close()</span><br><span class="line"></span><br><span class="line">reader = tf.TFRecordReader()</span><br><span class="line">filename_queue = tf.train.string_input_producer([<span class="string">"tmp.tfrecords"</span>],num_epochs=<span class="number">2</span>)</span><br><span class="line">_,serialized_example =reader.read(filename_queue)</span><br><span class="line"></span><br><span class="line">batch = tf.train.batch(tensors=[serialized_example],batch_size=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>在以上代码中我们展示了如何定义一个example并将其写入文件，同事19行开始我们也对如何读取文件做了简单示例，现在读取部分也可以使用dataset，更加符合官方潮流，例如用一下代码代替19-23行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataset = tf.data.TFRecordDataset(filenames=filenames, buffer_size=<span class="number">200</span>).batch(<span class="number">3</span>)</span><br><span class="line">record_iter = dataset.make_one_shot_iterator()</span><br></pre></td></tr></table></figure><p>下面进入重头戏，如何解析tfRecord的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">features=&#123;</span><br><span class="line">    <span class="string">"ft"</span>:tf.VarLenFeature(tf.float32),</span><br><span class="line">    <span class="string">"st"</span>:tf.VarLenFeature(tf.string)</span><br><span class="line">&#125;</span><br><span class="line">key_parsed = tf.parse_example(batch,features)</span><br><span class="line"></span><br><span class="line">sess.run(tf.initialize_local_variables())</span><br><span class="line"><span class="keyword">print</span> tf.contrib.learn.run_n(key_parsed) </span><br><span class="line"><span class="comment">#tf.train.get_or_create_global_step()</span></span><br><span class="line"><span class="comment">#print tf.contrib.training.train(key_parsed,'../')</span></span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&apos;ft&apos;: SparseTensorValue(indices=array([[0, 0],</span><br><span class="line">       [0, 1],</span><br><span class="line">       [1, 0],</span><br><span class="line">       [1, 1],</span><br><span class="line">       [2, 0],</span><br><span class="line">       [2, 1]]), values=array([1., 2., 2., 3., 1., 2.], dtype=float32), dense_shape=array([3, 2])), &apos;st&apos;: SparseTensorValue(indices=array([[0, 0],</span><br><span class="line">       [1, 0],</span><br><span class="line">       [2, 0]]), values=array([&apos;aaa&apos;, &apos;aaa&apos;, &apos;aaa&apos;], dtype=object), dense_shape=array([3, 1]))&#125;]</span><br></pre></td></tr></table></figure><p>其实非常简单，定义一个同样的feature，然后用相应的方法获取就可以了，注意代码的第8行的方法已经废弃了，TensorFlow相关人员表示没有开发其替代函数的打算，想实现相应的效果可以使用第9、10行的代码，基本可以替代，但是做实验的话由于train方法其实是在训练，还是8行的函数简单些，在删除前我们暂且继续使用。</p><p>在以上代码中我们使用的是VarlenFeature，它更通用一些，另外比较常见的还有FixedLenFeature，使用代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">features=&#123;</span><br><span class="line">    &quot;ft&quot;:tf.FixedLenFeature(shape=[2],dtype=tf.float32,default_value=[2.0,3.0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key_parsed = tf.parse_example(batch,features)</span><br><span class="line"></span><br><span class="line">print tf.contrib.learn.run_n(key_parsed)</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&apos;ft&apos;: array([[1., 2.],</span><br><span class="line">       [2., 3.],</span><br><span class="line">       [1., 2.]], dtype=float32)&#125;]</span><br></pre></td></tr></table></figure><p>这里需要注意的是它解析的数据必须是定长的，且数据格式与shape参数必须一致，否则就会报错。另外它返回的是一个tensor不同于VarLenFeature返回的是sparseTensor。这里default_value的意义是你查询的字段不存在时赋予默认值，比如你现在查询的是<em>ft</em>字段，如果存储时只存储了<em>st</em>那么就会使用默认值赋值，所以default_value，的shape必须与shape参数一致。</p><p>有了以上两个参数基本可以解决我们的数据读写问题，如果还不够，可以了解一下SparseFeature，它可以以一种类似SparseTensor的方式帮你定义数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">`serialized`:</span><br><span class="line">  [</span><br><span class="line">    features &#123;</span><br><span class="line">      feature &#123; key: &quot;val&quot; value &#123; float_list &#123; value: [ 0.5, -1.0 ] &#125; &#125; &#125;</span><br><span class="line">      feature &#123; key: &quot;ix&quot; value &#123; int64_list &#123; value: [ 3, 20 ] &#125; &#125; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    features &#123;</span><br><span class="line">      feature &#123; key: &quot;val&quot; value &#123; float_list &#123; value: [ 0.0 ] &#125; &#125; &#125;</span><br><span class="line">      feature &#123; key: &quot;ix&quot; value &#123; int64_list &#123; value: [ 42 ] &#125; &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">  #And arguments</span><br><span class="line">  example_names: [&quot;input0&quot;, &quot;input1&quot;],</span><br><span class="line">  features: &#123;</span><br><span class="line">      &quot;sparse&quot;: SparseFeature(</span><br><span class="line">          index_key=&quot;ix&quot;, value_key=&quot;val&quot;, dtype=tf.float32, size=100),</span><br><span class="line">  &#125;</span><br><span class="line">  #Then the output is a dictionary:</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;sparse&quot;: SparseTensor(</span><br><span class="line">        indices=[[0, 3], [0, 20], [1, 42]],</span><br><span class="line">        values=[0.5, -1.0, 0.0]</span><br><span class="line">        dense_shape=[2, 100]),</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="其它相关函数"><a href="#其它相关函数" class="headerlink" title="其它相关函数"></a>其它相关函数</h2><p>除了以上用到的parse_example方法，还有一些其它方法我们可以简单了解。</p><h3 id="tf-parse-single-example"><a href="#tf-parse-single-example" class="headerlink" title="tf.parse_single_example"></a>tf.parse_single_example</h3><p>该方法与tf.parse_example方法基本相同，只不过少了batch函数，单独解析</p><h3 id="tf-parse-single-sequence-example"><a href="#tf-parse-single-sequence-example" class="headerlink" title="tf.parse_single_sequence_example"></a>tf.parse_single_sequence_example</h3><p>说到这个方法我们就得提一下tf.train.SequenceExample，望文生义，它与tf.train.Example方法的不同之处在于它多了一个边长的list部分，定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message SequenceExample &#123;</span><br><span class="line">  Features context = 1;</span><br><span class="line">  FeatureLists feature_lists = 2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们以源码中电影打分示例来了解一下SequenceExample</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// context: &#123;</span><br><span class="line">//   feature: &#123;</span><br><span class="line">//     key  : &quot;locale&quot;</span><br><span class="line">//     value: &#123;</span><br><span class="line">//       bytes_list: &#123;</span><br><span class="line">//         value: [ &quot;pt_BR&quot; ]</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">//   feature: &#123;</span><br><span class="line">//     key  : &quot;age&quot;</span><br><span class="line">//     value: &#123;</span><br><span class="line">//       float_list: &#123;</span><br><span class="line">//         value: [ 19.0 ]</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">//   feature: &#123;</span><br><span class="line">//     key  : &quot;favorites&quot;</span><br><span class="line">//     value: &#123;</span><br><span class="line">//       bytes_list: &#123;</span><br><span class="line">//         value: [ &quot;Majesty Rose&quot;, &quot;Savannah Outen&quot;, &quot;One Direction&quot; ]</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// feature_lists: &#123;</span><br><span class="line">//   feature_list: &#123;</span><br><span class="line">//     key  : &quot;movie_ratings&quot;</span><br><span class="line">//     value: &#123;</span><br><span class="line">//       feature: &#123;</span><br><span class="line">//         float_list: &#123;</span><br><span class="line">//           value: [ 4.5 ]</span><br><span class="line">//         &#125;</span><br><span class="line">//       &#125;</span><br><span class="line">//       feature: &#123;</span><br><span class="line">//         float_list: &#123;</span><br><span class="line">//           value: [ 5.0 ]</span><br><span class="line">//         &#125;</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">//   feature_list: &#123;</span><br><span class="line">//     key  : &quot;movie_names&quot;</span><br><span class="line">//     value: &#123;</span><br><span class="line">//       feature: &#123;</span><br><span class="line">//         bytes_list: &#123;</span><br><span class="line">//           value: [ &quot;The Shawshank Redemption&quot; ]</span><br><span class="line">//         &#125;</span><br><span class="line">//       &#125;</span><br><span class="line">//       feature: &#123;</span><br><span class="line">//         bytes_list: &#123;</span><br><span class="line">//           value: [ &quot;Fight Club&quot; ]</span><br><span class="line">//         &#125;</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">//   feature_list: &#123;</span><br><span class="line">//     key  : &quot;actors&quot;</span><br><span class="line">//     value: &#123;</span><br><span class="line">//       feature: &#123;</span><br><span class="line">//         bytes_list: &#123;</span><br><span class="line">//           value: [ &quot;Tim Robbins&quot;, &quot;Morgan Freeman&quot; ]</span><br><span class="line">//         &#125;</span><br><span class="line">//       &#125;</span><br><span class="line">//       feature: &#123;</span><br><span class="line">//         bytes_list: &#123;</span><br><span class="line">//           value: [ &quot;Brad Pitt&quot;, &quot;Edward Norton&quot;, &quot;Helena Bonham Carter&quot; ]</span><br><span class="line">//         &#125;</span><br><span class="line">//       &#125;</span><br><span class="line">//     &#125;</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">//</span><br></pre></td></tr></table></figure><p>这是一个用户的电影打分记录，context部分是这个用户不随时间变化的固定属性，而feature_list中就是他观看过的电影，电影的演员，以及对电影打分的记录，是可以一直记录下去的。</p><p>官方总结的原则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Context:</span><br><span class="line">//   - All conformant context features K must obey the same conventions as</span><br><span class="line">//     a conformant Example&apos;s features (see above).</span><br><span class="line">// Feature lists:</span><br><span class="line">//   - A FeatureList L may be missing in an example; it is up to the</span><br><span class="line">//     parser configuration to determine if this is allowed or considered</span><br><span class="line">//     an empty list (zero length).</span><br><span class="line">//   - If a FeatureList L exists, it may be empty (zero length).</span><br><span class="line">//   - If a FeatureList L is non-empty, all features within the FeatureList</span><br><span class="line">//     must have the same data type T. Even across SequenceExamples, the type T</span><br><span class="line">//     of the FeatureList identified by the same key must be the same. An entry</span><br><span class="line">//     without any values may serve as an empty feature.</span><br><span class="line">//   - If a FeatureList L is non-empty, it is up to the parser configuration</span><br><span class="line">//     to determine if all features within the FeatureList must</span><br><span class="line">//     have the same size.  The same holds for this FeatureList across multiple</span><br><span class="line">//     examples.</span><br></pre></td></tr></table></figure><p>没有什么复杂的，只是讨论了数据缺失的可能性，另外需要注意list的长度是否固定取决于解析时的设置，例如使用FixedLenSequenceFeature时就会要求等长。</p><p>而tf.parse_single_sequence_example就是解析此种数据格式的，与parse_example大同小异，这里就不展开了，也可以从参考资料中找到示例代码</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/u010223750/article/details/70482498" target="_blank" rel="noopener">Tensorflow高阶读写教程</a></p><p><a href="https://github.com/tensorflow/tensorflow/blob/r1.7/tensorflow/python/ops/parsing_ops.py" target="_blank" rel="noopener">TensorFlow源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tfRecord是TensorFlow官方推荐的标准数据格式，对于存储字典类型的数据比较友好，所以撰写此文记录一下使用过程中的一点经验。&lt;/p&gt;
&lt;h2 id=&quot;tfRecord结构&quot;&gt;&lt;a href=&quot;#tfRecord结构&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="TensorFlow" scheme="http://yoursite.com/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
      <category term="tfRecord" scheme="http://yoursite.com/tags/tfRecord/"/>
    
      <category term="tf.contrib.learn.run_n" scheme="http://yoursite.com/tags/tf-contrib-learn-run-n/"/>
    
  </entry>
  
  <entry>
    <title>mysql中对多个字段进行去重计数</title>
    <link href="http://yoursite.com/2017/11/30/mysql%E4%B8%AD%E5%AF%B9%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E5%8E%BB%E9%87%8D%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2017/11/30/mysql中对多个字段进行去重计数/</id>
    <published>2017-11-30T18:45:45.000Z</published>
    <updated>2018-12-12T09:13:10.811Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到了一个奇怪的bug，举例如下，假设有一张表table</p><table><thead><tr><th>colA</th><th>colB</th><th>colC</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>NULL</td></tr><tr><td>a2</td><td>b2</td><td>NULL</td></tr><tr><td>a3</td><td>b3</td><td>NULL</td></tr></tbody></table><p>当我们使用<code>SELECT COUNT(DISTINCT colA,colB,colC) FROM talbe</code>进行查询时，返回的竟然是0。但是我们使用<code>SELECT DISTINCT colA,colB,colC FROM talbe</code>可以正常获取三行数据，后来在<a href="https://stackoverflow.com/questions/18968963/select-countdistinct-error-on-multiple-columns" target="_blank" rel="noopener">Stack Overflow</a>上看到SQL_Server中count只支持三种格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COUNT(*)</span><br><span class="line">COUNT(colName)</span><br><span class="line">COUNT(DISTINCT colName)</span><br></pre></td></tr></table></figure><p>而查询mysql相关文档没看到这种说法，官方文档中只有count(*)的示例，所以只能认为也是相同的，最终将查询代码改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM (SELECT DISTINCT colA,colB,colC FROM talbe) A</span><br></pre></td></tr></table></figure><p>成功的解决了问题，所以在多维度去重的情况下要特别注意，使用正确的语法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天遇到了一个奇怪的bug，举例如下，假设有一张表table&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;colA&lt;/th&gt;
&lt;th&gt;colB&lt;/th&gt;
&lt;th&gt;colC&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;a1&lt;/td&gt;
      
    
    </summary>
    
      <category term="sql相关" scheme="http://yoursite.com/categories/sql%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="count distinct" scheme="http://yoursite.com/tags/count-distinct/"/>
    
  </entry>
  
  <entry>
    <title>hexo设置持续集成过程中遇到的一些问题</title>
    <link href="http://yoursite.com/2017/11/26/hexo%E8%AE%BE%E7%BD%AE%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/11/26/hexo设置持续集成过程中遇到的一些问题/</id>
    <published>2017-11-26T19:42:55.000Z</published>
    <updated>2018-12-12T09:13:10.780Z</updated>
    
    <content type="html"><![CDATA[<p>由于hexo d的方式来布置hexo博客不能满足多台计算机编辑以及备份的需求，所以参考<a href="https://formulahendry.github.io/2016/12/04/hexo-ci/" target="_blank" rel="noopener">Hexo的版本控制与持续集成</a>的博客，进行了持续集成的配置，效果显著， 终于可以随时随地的编辑博客了。</p><p>但是这个过程中也遇到一个问题，就是当我们使用第三方主题的时候（我使用的是next）主题文件夹不能上传到source repository，原因也很简单，因为我是直接使用<code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code>克隆的next主题，所以next文件夹下有.git，是一个独立的repo，当然无法上传，删掉.git后就一切正常了，但这也带来另一个问题，就是我们想更新主题的时候比较麻烦，因为已经是一个独立的本地文件夹了，后来经过搜索，确定了使用git subtree来解决这个问题。</p><p>关于git subtree的内容大家可以自行网上搜索，简单来说就是git用来管理子项目的一种方式，整个操作过程如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 添加next仓库，命名为next</span><br><span class="line">git remote add next https://github.com/iissnan/hexo-theme-next</span><br><span class="line"><span class="meta">#</span>添加next的master分支到子树</span><br><span class="line">git subtree add --prefix=themes/next  next master --squash</span><br><span class="line"><span class="meta">#</span>看看有哪些稳定版本</span><br><span class="line">git ls-remote --tags next</span><br><span class="line"><span class="meta">#</span>测试切换到5.1.2版本</span><br><span class="line">git subtree pull --prefix=themes/next  next tags/v5.1.2 --squash</span><br><span class="line"><span class="meta">#</span>测试切换到5.1.3版本</span><br><span class="line">git subtree pull --prefix=themes/next  next tags/v5.1.3 --squash</span><br></pre></td></tr></table></figure><p>在切换到5.1.2版本后，我修改了主题配置文件，添加了livere_uid(來必力评论配置，在next主题下配置这一行就可以开启，简单易配置，不翻墙就可以评论，推荐大家使用)，然后尝试切换到5.1.3版本，发现很智能保留了这个配置（两个版本的配置文件是不同的，merge的过程很顺利），所以通过这个方案切换新版本应该是可行的。</p><p>这里需要注意的即使代码的第4行，我一开始写的是<code>git subtree add --prefix=themes/next  next tags/v5.1.2 --squash</code>，在这样的情况下5.1.2版本的下载倒是没有问题，但是更新到5.1.3时，会提示已经是最新的代码无法更新，相信大多数人还是以稳定版为主，如果不是想折腾一下源码的话，所以推荐按照现在的顺序来配置。</p><hr><p>更新：</p><p>最近持续集成过程中出错，提示node版本太低，参考了这边<a href="https://killerlei.github.io/2017/04/06/hexo-github-AppVeyor%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%86%99%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">博文</a>, 在appveyor.xml配置文件中新增</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Get the latest stable version of Node.js or io.js</span><br><span class="line">- ps: Install-Product node $env:nodejs_version</span><br><span class="line"># install modules</span><br><span class="line">- npm install</span><br></pre></td></tr></table></figure><p>也即node更新语句后解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于hexo d的方式来布置hexo博客不能满足多台计算机编辑以及备份的需求，所以参考&lt;a href=&quot;https://formulahendry.github.io/2016/12/04/hexo-ci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;H
      
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="CI" scheme="http://yoursite.com/tags/CI/"/>
    
      <category term="git subtree" scheme="http://yoursite.com/tags/git-subtree/"/>
    
      <category term="來必力" scheme="http://yoursite.com/tags/%E4%BE%86%E5%BF%85%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>yii1.1版本下访问数据库时需要注意的问题</title>
    <link href="http://yoursite.com/2017/11/26/yii1-1%E7%89%88%E6%9C%AC%E4%B8%8B%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/11/26/yii1-1版本下访问数据库时需要注意的问题/</id>
    <published>2017-11-26T19:42:55.000Z</published>
    <updated>2018-12-12T09:13:10.827Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章提到我们使用了greenplum来代替mysql来适应数据规模较大的情况，同时尽量保证小的改动。服务端我们使用的是yii1.1版本，之所以不是2.0原因很简单，历史选择。但在使用greenplum的过程中我们发现某些查询下速度特别慢，后经过各种测试发现，一旦调用了prepare方法，在数据量较大时速度就会特别慢，怀疑时greenplum优化的问题，但由于使用的是dba自己改造后的版本，也就没有深究其官方版本是不是也存在这样的bug。</p><p>那么现在的问题就变成了我们使用的是CDbcommand模块queryAll方法，并没有调用其prepare方法，那么为什么还会慢的，阅读其源码发现，所有的query方法，最终都是靠queryInternal方法实现的，在该函数的32行我们不难发现，默认情况先总会调用prepare函数，所以即使我们没有显示的调用CDbcommand的prepare方法，最终还是难以避免这一点。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">queryInternal</span><span class="params">($method,$mode,$params=array<span class="params">()</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$params=array_merge(<span class="keyword">$this</span>-&gt;params,$params);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;_connection-&gt;enableParamLogging &amp;&amp; ($pars=array_merge(<span class="keyword">$this</span>-&gt;_paramLog,$params))!==<span class="keyword">array</span>())</span><br><span class="line">&#123;</span><br><span class="line">$p=<span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span>($pars <span class="keyword">as</span> $name=&gt;$value)</span><br><span class="line">$p[$name]=$name.<span class="string">'='</span>.var_export($value,<span class="keyword">true</span>);</span><br><span class="line">$par=<span class="string">'. Bound with '</span>.implode(<span class="string">', '</span>,$p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">$par=<span class="string">''</span>;</span><br><span class="line">Yii::trace(<span class="string">'Querying SQL: '</span>.<span class="keyword">$this</span>-&gt;getText().$par,<span class="string">'system.db.CDbCommand'</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;_connection-&gt;queryCachingCount&gt;<span class="number">0</span> &amp;&amp; $method!==<span class="string">''</span></span><br><span class="line">&amp;&amp; <span class="keyword">$this</span>-&gt;_connection-&gt;queryCachingDuration&gt;<span class="number">0</span></span><br><span class="line">&amp;&amp; <span class="keyword">$this</span>-&gt;_connection-&gt;queryCacheID!==<span class="keyword">false</span></span><br><span class="line">&amp;&amp; ($cache=Yii::app()-&gt;getComponent(<span class="keyword">$this</span>-&gt;_connection-&gt;queryCacheID))!==<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;_connection-&gt;queryCachingCount--;</span><br><span class="line">$cacheKey=<span class="string">'yii:dbquery'</span>.<span class="string">':'</span>.$method.<span class="string">':'</span>.<span class="keyword">$this</span>-&gt;_connection-&gt;connectionString.<span class="string">':'</span>.<span class="keyword">$this</span>-&gt;_connection-&gt;username;</span><br><span class="line">$cacheKey.=<span class="string">':'</span>.<span class="keyword">$this</span>-&gt;getText().<span class="string">':'</span>.serialize(array_merge(<span class="keyword">$this</span>-&gt;_paramLog,$params));</span><br><span class="line"><span class="keyword">if</span>(($result=$cache-&gt;get($cacheKey))!==<span class="keyword">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">Yii::trace(<span class="string">'Query result found in cache'</span>,<span class="string">'system.db.CDbCommand'</span>);</span><br><span class="line"><span class="keyword">return</span> $result[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;_connection-&gt;enableProfiling)</span><br><span class="line">Yii::beginProfile(<span class="string">'system.db.CDbCommand.query('</span>.<span class="keyword">$this</span>-&gt;getText().$par.<span class="string">')'</span>,<span class="string">'system.db.CDbCommand.query'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;prepare();</span><br><span class="line"><span class="keyword">if</span>($params===<span class="keyword">array</span>())</span><br><span class="line"><span class="keyword">$this</span>-&gt;_statement-&gt;execute();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;_statement-&gt;execute($params);</span><br><span class="line"><span class="keyword">if</span>($method===<span class="string">''</span>)</span><br><span class="line">$result=<span class="keyword">new</span> CDbDataReader(<span class="keyword">$this</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">$mode=(<span class="keyword">array</span>)$mode;</span><br><span class="line">call_user_func_array(<span class="keyword">array</span>(<span class="keyword">$this</span>-&gt;_statement, <span class="string">'setFetchMode'</span>), $mode);</span><br><span class="line">$result=<span class="keyword">$this</span>-&gt;_statement-&gt;$method();</span><br><span class="line"><span class="keyword">$this</span>-&gt;_statement-&gt;closeCursor();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;_connection-&gt;enableProfiling)</span><br><span class="line">Yii::endProfile(<span class="string">'system.db.CDbCommand.query('</span>.<span class="keyword">$this</span>-&gt;getText().$par.<span class="string">')'</span>,<span class="string">'system.db.CDbCommand.query'</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($cache,$cacheKey))</span><br><span class="line">$cache-&gt;set($cacheKey, <span class="keyword">array</span>($result), <span class="keyword">$this</span>-&gt;_connection-&gt;queryCachingDuration, <span class="keyword">$this</span>-&gt;_connection-&gt;queryCachingDependency);</span><br><span class="line"><span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">Exception</span> $e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;_connection-&gt;enableProfiling)</span><br><span class="line">Yii::endProfile(<span class="string">'system.db.CDbCommand.query('</span>.<span class="keyword">$this</span>-&gt;getText().$par.<span class="string">')'</span>,<span class="string">'system.db.CDbCommand.query'</span>);</span><br><span class="line">$errorInfo=$e <span class="keyword">instanceof</span> PDOException ? $e-&gt;errorInfo : <span class="keyword">null</span>;</span><br><span class="line">$message=$e-&gt;getMessage();</span><br><span class="line">Yii::log(Yii::t(<span class="string">'yii'</span>,<span class="string">'CDbCommand::&#123;method&#125;() failed: &#123;error&#125;. The SQL statement executed was: &#123;sql&#125;.'</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">'&#123;method&#125;'</span>=&gt;$method, <span class="string">'&#123;error&#125;'</span>=&gt;$message, <span class="string">'&#123;sql&#125;'</span>=&gt;<span class="keyword">$this</span>-&gt;getText().$par)),CLogger::LEVEL_ERROR,<span class="string">'system.db.CDbCommand'</span>);</span><br><span class="line"><span class="keyword">if</span>(YII_DEBUG)</span><br><span class="line">$message.=<span class="string">'. The SQL statement executed was: '</span>.<span class="keyword">$this</span>-&gt;getText().$par;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CDbException(Yii::t(<span class="string">'yii'</span>,<span class="string">'CDbCommand failed to execute the SQL statement: &#123;error&#125;'</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">'&#123;error&#125;'</span>=&gt;$message)),(int)$e-&gt;getCode(),$errorInfo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的解决方案是在配置中加了’emulatePrepare’ =&gt; true的配置，该配置项其实就是启用了pdo中的模拟预处理，用模拟预处理代替greenplum龟速的预处理，最终解决了该问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章提到我们使用了greenplum来代替mysql来适应数据规模较大的情况，同时尽量保证小的改动。服务端我们使用的是yii1.1版本，之所以不是2.0原因很简单，历史选择。但在使用greenplum的过程中我们发现某些查询下速度特别慢，后经过各种测试发现，一旦调用了p
      
    
    </summary>
    
      <category term="web开发" scheme="http://yoursite.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="数据库访问" scheme="http://yoursite.com/categories/web%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE/"/>
    
    
      <category term="greenplum" scheme="http://yoursite.com/tags/greenplum/"/>
    
      <category term="yii" scheme="http://yoursite.com/tags/yii/"/>
    
      <category term="emulate prepare" scheme="http://yoursite.com/tags/emulate-prepare/"/>
    
  </entry>
  
  <entry>
    <title>mysql与postgresql的区别</title>
    <link href="http://yoursite.com/2017/11/14/mysql%E4%B8%8Epostgresql%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/11/14/mysql与postgresql的区别/</id>
    <published>2017-11-14T23:11:19.000Z</published>
    <updated>2018-12-12T09:13:10.811Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中由于数据量太大时mysql负载的压力，我们引入了greenplum做我们大数据量表格的数据库，选择greenplum的原因是它在解决大数据存储的同时，尽可能的保持了和mysql一样的操作逻辑（同是关系型数据库，使用sql查询），减小了我们的迁移成本，但是尽管如此，greenplum基于的postgresql引擎和mysql还是存在一定的差异，此文对目前遇到的问题进行了记录，以防止以后再次出现同样的问题。</p><ol><li><p>反引号的区别</p><p>在mysql中，对于保留字使用反引号来加以区分，例如想查询一个表中的select字段，由于select是保留字我们需写成</p><p><code>SELECT `select` FROM table</code></p><p>而在postgresql中不存在这种写法，当identifier为保留字时，则使用双引号</p><p><code>SELECT &quot;select&quot; FROM table</code></p></li><li><p>limit的差别</p><p>在mysql中limit可以间简写为<code>limit 10,100</code>，其等价于<code>limit 100 offset 10</code>而在postgresql中只能采用第二种标准的sql方式</p></li><li><p>对if语句的支持</p><p>mysql支持if 语句，例如<code>if(x&gt;1,1,0)</code>而postgresql只支持case when语句</p></li><li><p>大小写</p><p>mysql中是不区分大小写的，你查询一个字段，写大小写都可以，而在postgresql中是区分大小写的，如果想要字段名大些，必须用双引号将其扩起，由于一些历史原因mysql中使用了大写的字段名，查询也没有问题，但是到postgresql中就失败了，所以建议在sql中，采用下划线分割，不要使用驼峰命名发</p></li></ol><p>以上就是目前遇到的mysql迁移greenplum过程中遇到的一些问题，可以看到大部分是因为mysql在标准sql的基础上给我们提供了更加方便的解决方式，但这种方式在迁移数据库时会给我们带来意想不到的麻烦，所以除非肯定只用一种数据库，否则还是建议按照标准sql书写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在工作中由于数据量太大时mysql负载的压力，我们引入了greenplum做我们大数据量表格的数据库，选择greenplum的原因是它在解决大数据存储的同时，尽可能的保持了和mysql一样的操作逻辑（同是关系型数据库，使用sql查询），减小了我们的迁移成本，但是尽管如此，g
      
    
    </summary>
    
      <category term="sql相关" scheme="http://yoursite.com/categories/sql%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="postgresql" scheme="http://yoursite.com/tags/postgresql/"/>
    
      <category term="greenplum" scheme="http://yoursite.com/tags/greenplum/"/>
    
  </entry>
  
</feed>
